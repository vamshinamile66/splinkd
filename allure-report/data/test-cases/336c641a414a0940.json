{"uid":"336c641a414a0940","name":"test_login_correct_username_correct_password","fullName":"tests.test_login#test_login_correct_username_correct_password","historyId":"73be65653c7801c1b3e9ad3c4844d02f","time":{"start":1756628799338,"stop":1756628799338,"duration":0},"description":"Test login with correct username and correct password.","descriptionHtml":"<p>Test login with correct username and correct password.</p>\n","status":"broken","statusMessage":"requests.exceptions.ChunkedEncodingError: ('Connection broken: IncompleteRead(2891412 bytes read, 6191374 more expected)', IncompleteRead(2891412 bytes read, 6191374 more expected))","statusTrace":"self = <urllib3.response.HTTPResponse object at 0x000001D0630EE410>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\nvenv\\Lib\\site-packages\\urllib3\\response.py:754: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x000001D0630EE410>, amt = 10240\n\n    def _raw_read(\n        self,\n        amt: int | None = None,\n        *,\n        read1: bool = False,\n    ) -> bytes:\n        \"\"\"\n        Reads `amt` of bytes from the socket.\n        \"\"\"\n        if self._fp is None:\n            return None  # type: ignore[return-value]\n    \n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            data = self._fp_read(amt, read1=read1) if not fp_closed else b\"\"\n            if amt is not None and amt != 0 and not data:\n                # Platform-specific: Buggy versions of Python.\n                # Close the connection when no data is returned\n                #\n                # This is redundant to what httplib/http.client _should_\n                # already do.  However, versions of python released before\n                # December 15, 2012 (http://bugs.python.org/issue16298) do\n                # not properly close the connection in all cases. There is\n                # no harm in redundantly calling close.\n                self._fp.close()\n                if (\n                    self.enforce_content_length\n                    and self.length_remaining is not None\n                    and self.length_remaining != 0\n                ):\n                    # This is an edge case that httplib failed to cover due\n                    # to concerns of backward compatibility. We're\n                    # addressing it here to make sure IncompleteRead is\n                    # raised during streaming, so all calls with incorrect\n                    # Content-Length are caught.\n>                   raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\nE                   urllib3.exceptions.IncompleteRead: IncompleteRead(2891412 bytes read, 6191374 more expected)\n\nvenv\\Lib\\site-packages\\urllib3\\response.py:900: IncompleteRead\n\nThe above exception was the direct cause of the following exception:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n>               yield from self.raw.stream(chunk_size, decode_content=True)\n\nvenv\\Lib\\site-packages\\requests\\models.py:820: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\urllib3\\response.py:1066: in stream\n    data = self.read(amt=amt, decode_content=decode_content)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\urllib3\\response.py:983: in read\n    data = self._raw_read(amt)\n           ^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\urllib3\\response.py:878: in _raw_read\n    with self._error_catcher():\nC:\\Program Files\\WindowsApps\\PythonSoftwareFoundation.Python.3.11_3.11.2544.0_x64__qbz5n2kfra8p0\\Lib\\contextlib.py:158: in __exit__\n    self.gen.throw(typ, value, traceback)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x000001D0630EE410>\n\n    @contextmanager\n    def _error_catcher(self) -> typing.Generator[None]:\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout as e:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e) from e\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\") from e  # type: ignore[arg-type]\n    \n            except IncompleteRead as e:\n                if (\n                    e.expected is not None\n                    and e.partial is not None\n                    and e.expected == -e.partial\n                ):\n                    arg = \"Response may not contain content.\"\n                else:\n                    arg = f\"Connection broken: {e!r}\"\n>               raise ProtocolError(arg, e) from e\nE               urllib3.exceptions.ProtocolError: ('Connection broken: IncompleteRead(2891412 bytes read, 6191374 more expected)', IncompleteRead(2891412 bytes read, 6191374 more expected))\n\nvenv\\Lib\\site-packages\\urllib3\\response.py:778: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.fixture(scope=\"session\")\n    def driver():\n        browser = config[\"browser\"].strip().lower()\n        if browser == \"chrome\":\n>           service = ChromeService(ChromeDriverManager().install())\n                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nconftest.py:18: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nvenv\\Lib\\site-packages\\webdriver_manager\\chrome.py:40: in install\n    driver_path = self._get_driver_binary_path(self.driver)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\webdriver_manager\\core\\manager.py:40: in _get_driver_binary_path\n    file = self._download_manager.download_file(driver.get_driver_download_url(os_type))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\webdriver_manager\\core\\download_manager.py:32: in download_file\n    return File(response, file_name)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\webdriver_manager\\core\\file_manager.py:12: in __init__\n    self.content = stream.content\n                   ^^^^^^^^^^^^^^\nvenv\\Lib\\site-packages\\requests\\models.py:902: in content\n    self._content = b\"\".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b\"\"\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, \"stream\"):\n            try:\n                yield from self.raw.stream(chunk_size, decode_content=True)\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: ('Connection broken: IncompleteRead(2891412 bytes read, 6191374 more expected)', IncompleteRead(2891412 bytes read, 6191374 more expected))\n\nvenv\\Lib\\site-packages\\requests\\models.py:822: ChunkedEncodingError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"driver","time":{"start":1756628799340,"stop":1756628922973,"duration":123633},"status":"broken","statusMessage":"requests.exceptions.ChunkedEncodingError: ('Connection broken: IncompleteRead(2891412 bytes read, 6191374 more expected)', IncompleteRead(2891412 bytes read, 6191374 more expected))\n","statusTrace":"  File \"C:\\splinkd\\venv\\Lib\\site-packages\\pluggy\\_callers.py\", line 38, in run_old_style_hookwrapper\n    res = yield\n          ^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\pluggy\\_callers.py\", line 139, in _multicall\n    teardown.throw(exception)\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\_pytest\\setuponly.py\", line 36, in pytest_fixture_setup\n    return (yield)\n            ^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\pluggy\\_callers.py\", line 121, in _multicall\n    res = hook_impl.function(*args)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\_pytest\\fixtures.py\", line 1195, in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\_pytest\\fixtures.py\", line 922, in call_fixture_func\n    fixture_result = next(generator)\n                     ^^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\conftest.py\", line 18, in driver\n    service = ChromeService(ChromeDriverManager().install())\n                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\webdriver_manager\\chrome.py\", line 40, in install\n    driver_path = self._get_driver_binary_path(self.driver)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\webdriver_manager\\core\\manager.py\", line 40, in _get_driver_binary_path\n    file = self._download_manager.download_file(driver.get_driver_download_url(os_type))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\webdriver_manager\\core\\download_manager.py\", line 32, in download_file\n    return File(response, file_name)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\webdriver_manager\\core\\file_manager.py\", line 12, in __init__\n    self.content = stream.content\n                   ^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\requests\\models.py\", line 902, in content\n    self._content = b\"\".join(self.iter_content(CONTENT_CHUNK_SIZE)) or b\"\"\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\splinkd\\venv\\Lib\\site-packages\\requests\\models.py\", line 822, in generate\n    raise ChunkedEncodingError(e)\n","steps":[],"attachments":[],"parameters":[],"hasContent":true,"attachmentStep":false,"stepsCount":0,"shouldDisplayMessage":true,"attachmentsCount":0}],"afterStages":[],"labels":[{"name":"parentSuite","value":"tests"},{"name":"suite","value":"test_login"},{"name":"host","value":"OTSI-Lap80"},{"name":"thread","value":"84668-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.test_login"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":true,"retry":true,"extra":{"categories":[],"tags":[]},"source":"336c641a414a0940.json","parameterValues":[]}